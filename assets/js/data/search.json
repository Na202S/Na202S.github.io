[ { "title": "健身先健脑，科学减脂之运动篇！", "url": "/posts/fatloss-sports/", "categories": "Fitness", "tags": "health, fatloss", "date": "2022-06-12 23:29:00 +0000", "snippet": "1、搞清楚自己在练什么，才能真正减肥丨有氧OR无氧？1.1 人体供能系统人体三大供能系统分别是：ATP-CP系统、糖酵解系统、有氧系统。人体的直接能量来源是：ATP（三磷酸腺苷）。ATP在ATP酶的催化下，迅速水解为ADP（二磷酸腺苷）和Pi（无机磷酸），并释放出能量。人体三大供能系统的作用就是生成ATP供能。 这三个系统在任何运动中都是同时存在的，只是在不同的阶段，三者供能的比例不同而已。1.1.1 ATP-CP 系统细胞内只储存了少量ATP，进行剧烈运动时，仅能维持1～3s，之后的能量供应需要依靠ATP的再生。细胞内的另一种高能磷酸分子——磷酸肌酸（CP）可以通过分解作用提供能量和无机磷酸，使ADP重新合成ATP，从而维持ATP的稳定。此过程非常迅速，在无氧和有氧条件下均可进行。像短跑这样的大强度运动，在其最初的几秒内，ATP含量维持在一个相对不变的水平，但磷酸肌酸含量却不断下降，因为其要补充消耗的ATP。力竭时，ATP和磷酸肌酸含量均显著降低，以至于不能继续提供能量来维持肌肉的收缩和舒张。ATP-CP系统的特点： 不需要氧（有氧条件下也可进行）； 输出功率大、可维持时间短（6-8s），是短时间、极高强度运动（比如短跑、跳跃、举重）的主要供能系统。 1.1.2 糖酵解系统（无氧乳酸系统）无氧条件下，糖原或葡萄糖通过酵解途径生成ATP和乳酸。糖酵解系统的特点： 不需要氧； 输出功率一般，可维持2-3min，是中等时间、高强度运动（比如800m跑）的主要供能系统； 产生乳酸，乳酸累积过多会导致疲劳。 1.1.3 有氧系统有氧条件下，人体三大能源物质（糖、脂肪和蛋白质）通过氧化作用，生成ATP供能。有氧系统的特点： 需要氧； 输出功率小、可维持时间长，是持续的长时间中低强度耐力性运动（比如慢跑）的主要供能系统。 1.2 人体三大供能系统与运动的关系1.2.1 有氧运动在运动过程中，身体的供能主要是有氧氧化，能量来源以脂肪为主。可以长时间坚持不停歇的、通常在30分钟以上的、稳定有节律性的、低强度的运动。慢跑、快走、游泳、椭圆机、健身操等。1.2.2 无氧运动在运动过程中，身体的供能主要是无氧糖酵解，能量来源主要以糖原为主。短时间的、需要间歇的、高强度的、强烈刺激肌肉的运动。撸铁、固定器械训练、HIIT、TABATA等。 并不存在绝对的有氧运动和绝对的无氧运动。同样的运动在不同的强度当中，供能方式会有所改变的。2、如何才能让你的减脂效率最大化/事半功倍的训练方法2.1 有氧运动 vs 无氧运动2.1.1 有氧运动最大的优点：改善心肺功能、增加多巴胺的分泌、调节心情、放松压力。但是只通过做有氧想减脂，非常困难。原因如下： 有氧训练强度较低，单位时间内热量消耗少，大众有氧每小时的平均消耗只有350大卡； 身体对于有氧训练的适应性非常强，需要不断地增加强度才能持续消耗热量； 长期有氧训练会增加皮质醇激素的分泌，会分解代谢肌肉，从而降低我们的基础代谢。2.1.2 无氧运动最大的缺点：入门难度较高，需要有一定的训练基础和经验。优点如下： 单位时间内热量消耗高，中高强度的力量训练，每小时平均消耗大概500大卡； 有效增加身体肌肉量，增加基础代谢； 紧致塑型的效果； 可以因人而异地制定训练方案，针对各种体态问题进行改善。2.2 安排训练2.2.1 中等体重每周训练5天，每次训练40-60分钟中等强度无氧，之后40分钟有氧。完整流程：5分钟热身——40-60分钟无氧训练——40分钟有氧训练——5分钟拉伸。周一，二，三训练，周四休息，周五，六训练，周日休息。每次无氧训练1-2个部位：胸，肩，背，手臂，臀，腿，腰腹核心。重点：背、臀、核心。2.2.2 小体重基数练三休一，每次做60分钟中高强度的力量训练，每次训练2个部位。胸背——臀腿——肩臂/核心，三天一循环。重点：背、臀、核心。每周额外做2次有氧，每次40分钟，中低强度即可。 减脂以及塑形的过程中，无氧训练的优先级是高于有氧训练的。2.3 运动强度2.3.1 有氧训练有氧训练的强度标准是心率。 低强度：&lt;= 50% 最大心率 中强度：50-70% 最大心率 高强度：70-80% 最大心率最大心率 = 220 - 年龄2.3.2 无氧训练 针对肌力以及爆发力：3-8RM 针对肌肥大以及塑形：8-12RM 针对肌耐力以及减脂：12-18RM$x$ RM：可以承受的、尽力且标准完成 $x$ 次的最大重量，完成 $x$ 次的训练并达到力竭的状态。 训练效果并不绝对，只是在不同强度下，侧重点不同而已。" }, { "title": "健身先健脑，科学减脂之饮食篇！", "url": "/posts/fatloss-food/", "categories": "Fitness", "tags": "health, fatloss", "date": "2022-06-11 22:29:00 +0000", "snippet": "1、导致肥胖的元凶是谁？怎么吃更不容易变胖？ 身体储存的脂肪变多了！1.1 三大营养元素 我们吃进去的食物含有能为身体提供热量的三大营养元素：碳水化合物、蛋白质、脂肪。这三种营养元素是如何被吸收的？吸收后去了哪里？是否转化为脂肪？怎么转化为脂肪？1.1.1 碳水化合物转化路径碳水化合物，也就是“糖”，主要来源是主食、水果、甜品等。通过消化腺被分解为葡萄糖等单糖形式，被人体吸收。吸收后的糖，首先被安排去补充血糖、肝糖、肌糖，这是路径 A。当这些地方的糖被补充充足之后，多余的糖就会被转化为脂肪储存在体内，这是路径 B。吃下等量碳水，血糖、肌糖水平低的情况下，或者肝糖、肌糖储存量更大的人，由于糖先走路径 A，就会有很少甚至没有碳水走路径 B，也就不会转化为脂肪。反之，血糖、肌糖水平高的情况下，或者肝糖、肌糖储存量小的人，这些碳水绝大部分都会通过路径 B 转化为脂肪储存在体内。在身体血糖、肝糖、肌糖水平比较低的时候吃碳水，更不容易变胖！ 结论 1：早晨起床后以及运动后是碳水摄入最佳时机。血糖、肝糖储存量相对稳定，而且本身量就比较小。但肌糖原量比较大，而且不同人区别也很大。肌肉越大，能储存的肌糖原就越多，摄入的碳水也就越不容易被储存为脂肪。 结论 2：通过力量训练提升肌糖的储存量。胰岛素变化胰岛素最主要的作用就是降低血糖。胰岛素的起伏决定了大脑判定是否饥饿、是否需要进食，以及是否吃饱了。当食物进入我们的体内，碳水开始吸收，血糖水平就会升高，这时候胰岛素就开始分泌，身体合成效应增加，热量储存。在胰岛素的作用下，血糖逐渐降低，我们会再次体感饥饿。如果碳水吸收的越快，血糖升得就越快，胰岛素来得就更快，后续血糖降得也越快，饥饿感来得也更快。 血糖波动幅度影响饥饿感。 GI（Glycemic Index：升糖指数）用于衡量糖类对血糖值的影响，是一种食物升高血糖能力的度量。GI值高的食物其所含糖类会被迅速分解然后吸收，将葡萄糖迅速释放到循环系统，导致血糖急剧上升再下降。反之，低GI值的食物其所含糖类会被缓慢分解或较慢吸收，使葡萄糖逐渐释放到循环系统，让血糖水平的上升和下降更加缓慢与平衡。 GL（Glycemic Load：升糖负荷）描述食物摄入后将如何升高人的血糖水平，1个单位的升糖负荷约相当于吃1克葡萄糖的效果。升糖负荷利用升糖指数“加权”食物中可吸收碳水化合物的量，计算公式为：GL = GI × 含糖百分比。计算例子如：西瓜的升糖指数很高，为72；但是西瓜的含糖量较低（约5%），因此西瓜的升糖负荷较低，100克西瓜的升糖负荷为：72 × 5% = 3.6。对于1份食物，升糖负荷大于20被认为是高的；在11-19为中等的；低于10为低负荷。 结论 3：吃GL低的食物，对血糖波动影响较小。吃得慢，给血糖升高、胰岛素分泌时间，判断是否吃饱。1.1.2 蛋白质广泛存在于肉类、蛋类、豆类产品中。摄入后被消化腺分解打散为单一的氨基酸，按需合成身体不同部位所需要的肌蛋白、角质蛋白、血红蛋白等等，参与到新陈代谢中。由于人体蛋白质一直处在新陈代谢的过程中，我们吃下去的蛋白质大部分都会参与到新陈代谢中，仅有少量的过剩蛋白质会转化为脂肪储存。所以，对于脂肪的影响是非常小的。此外，蛋白质有助于肌肉的合成。 结论 4：瘦肉类等高蛋白食物对于减肥存在极大帮助，多吃瘦肉类、简单烹饪的蛋白质更不容易变胖。1.1.3 脂肪当我们吃下去脂肪，消化腺会将其分解为脂肪酸以及甘油等。当细胞吸收这些物质后，其中一部分会参与氧化为身体供能，多余的部分会重新合成为甘油三酯，储存在脂肪细胞中。合成效应（合成代谢）当碳水和脂肪同时摄入的时候，我们从脂肪中获取的热量更容易被储存为脂肪！相反，单独吃脂肪，血糖波动小、胰岛素水平低，脂肪储存合成的可能性也就低。也就是说，如果吃同等热量的纯脂肪和碳水脂肪混合物，后者更容易变成脂肪储存在体内。碳水 + 脂肪 = 糖 + 油！ 也就是油炸食品、甜品、零食。 结论 5：单独吃碳水或者单独吃脂肪，比碳水加脂肪一起吃，更不容易变胖，吃得也更少。分解代谢 结论 6：频繁摄取糖油混合物、血糖频繁升高，即使摄入量很小，没有变胖，也一定会影响减肥速度。总结过量碳水、过量糖油混合物，导致胰岛素水平波动，是导致肥胖的最主要原因。同等热量情况下，容易变胖程度：糖油混合物 &gt; 纯碳水 &gt; 纯脂肪 &gt; 纯蛋白质。" }, { "title": "Berkeley CS61b：14. Disjoint Sets", "url": "/posts/notes14-Disjoint-Set/", "categories": "Courses, Berkeley CS61b", "tags": "data structures", "date": "2021-11-02 00:00:00 +0000", "snippet": "The Disjoint Sets Interfacepublic interface DisjointSets {\t/** Connects two items P and Q. */\tvoid connect(int p, int q);\t/** Checks to see if two items are connected. */\tboolean isConnected(int p, int q);}Representationconnect(5, 2)给每个节点分配一个 parent，用树的形式表示。 Find(x): 返回 x 的根节点，可以用 path compression 优化；（一般都优化） Union(x, y): 将 x 和 y 所属的树合并为一棵，方法是让 Find(x) 成为 Find(y) 的孩子。可以用 rank 优化，即总是让元素个数少的树连接到元素个数多的树下面。（一般不用优化）两个优化都是为了让树的高度尽可能低。Find The “disjoint set” mainly uses the find function to find the root node of a given vertex.Path CompressionDraw the tree after we callisConnected(14, 13)在寻找根节点的时候，将一路上经过的节点都连接到最终的根节点之后，使得它们成为根节点的孩子。Union The “disjoint set” mainly uses the union function to connect two vertices, x, and y, by equating their root node.Basic Unionconnect(5, 2) Find root(5). // returns 3 Find root(2). // returns 0 Set root(5)’s value equal to root(2). 通过 find 找到根节点，union 的时候，将 p 的根节点连接到 q 的根节点之后，使得 root(p) 成为 root(q) 的孩子。Union by Rank (Weighted Quick Union)Modify quick-union to avoid tall trees. Track tree size (number of elements). New rule: Always link root of smaller tree to larger tree. connect(3, 8)为什么用元素的个数，而不是树的高度？因为最坏的情况下都是 $ Θ(\\log(N)) $，而使用高度会使得代码更复杂。CodeImplementation of the “disjoint set”class UnionFind: # Constructor of Union-find. The size is the length of the root array. def __init__(self, size): def find(self, x): def union(self, x, y): def connected(self, x, y): The find function – optimized with path compression: def find(self, x): if self.parent[x] == x: return x self.parent[x] = self.find(self.parent[x]) return self.parent[x] A basic implementation of the union function: def union(self, x, y): rootX = self.find(x) rootY = self.find(y) if rootX != rootY: self.parent[rootY] = rootX The union function – Optimized by union by rank: (一般不用) def union(self, x, y): rootX = self.find(x) rootY = self.find(y) if rootX != rootY: if self.rank[rootY] &lt; self.rank[rootX]: self.parent[rootY] = rootX elif self.rank[rootX] &lt; self.rank[rootY]: self.parent[rootX] = rootY else: self.parent[rootY] = rootX self.rank[rootX] += 1 The connected function checks if two vertices, x and y, are connected def connected(self, x, y): return self.find(x) == self.find(y) " }, { "title": "Berkeley CS61b：13. Priority Queues and Heaps", "url": "/posts/notes13-PQ&heap/", "categories": "Courses, Berkeley CS61b", "tags": "data structures", "date": "2021-07-13 00:00:00 +0000", "snippet": "13.1 PQ InterfaceThe Priority Queue Interface(最小)优先队列：允许获取和移除队列中的最小项。在需要追踪”smallest”，“largest”，“best”时很有用。接口如下：添加项、获取最小项、删除最小项、队列大小。public interface MinPQ&lt;Item&gt; { public void add(Item x); public Item getSmallest(); public Item removeSmallest(); public int size();}Using Priority应用场景：每天追踪用户对话，报告 $M$ 条最有害的信息。public List&lt;String&gt; unharmoniousTexts(Sniffer sniffer, int M) {\tComparator&lt;String&gt; cmptr = new HarmoniousnessComparator();\t/* 用PQ来存放嗅探到的信息 */\tMinPQ&lt;String&gt; unharmoniousTexts = new HeapMinPQ&lt;Transaction&gt;(cmptr);\tfor (Timer timer = new Timer(); timer.hours() &lt; 24; ) {\t\tunharmoniousTexts.add(sniffer.getNextMessage());\t\t/* 在24小时之内，一旦PQ存储的信息多于M条 */\t\tif (unharmoniousTexts.size() &gt; M) {\t\t\t/* 就将PQ中最无害的信息删去 */\t\t\tunharmoniousTexts.removeSmallest();\t\t}\t}\tArrayList&lt;String&gt; textlist = new ArrayList&lt;String&gt;();\twhile (unharmoniousTexts.size() &gt; 0) {\t\t/* 将PQ中的信息依次加入List中 */\t\ttextlist.add(unharmoniousTexts.removeSmallest());\t}\treturn textlist;}13.2 HeapsHeap StructureBST 可以用来实现 PQ，但是将会很 bushy，而且不便处理优先级相同的项。取而代之，可以采用二叉最小堆（Binary min-Heap），即具有以下两个特性的二叉树： min-heap：每个节点都小于或等于它的左、右子节点。 complete：只在最低层有缺失的节点，且最低一层的节点全都尽量靠左。Heap Operations如何用二叉最小堆实现 PQ？ add(x)：为保证complete的特性，自然地想到可以先将 x 放到最低层的最左边的空位；但这样并不能保证min-heap的特性，故需要进一步的调整。 swim：不断地比较 x 和它的 parent 大小，假如 x 更小，就和 parent 进行交换，直到 x 放置到合适的位置。 getSmallest：由min-heap的特性可知，返回根节点即可。 removeSmallest：为保证complete的特性，自然地想到先将根节点和最末尾的节点进行交换，将换过位置以后的它删掉；但这样并不能保证min-heap的特性，故需要进一步的调整。 sink：不断地比较 x 和它的左、右节点大小，和二者中较小的节点进行交换，直到 x 放置到合适的位置。 Tree Representation在 Java 中，如何表示树结构？Approach 1a, 1b, and 1c建立节点到孩子节点的映射。1a：固定的 link 数；1b：用数组存放 link；1c：首孩子/sibling 的 link。Approach 2数组 keys 存放键值，表示每个索引 i 对应到哪个键值；再用数组 parents 存放 parent 的索引。即，1 个数组存放键值，1 个数组存放树的结构。一个更复杂的例子：e 为 b 的 parent，在 keys 数组中，和 e 对应的索引为1、和 b 对应的索引为3；在parents 数组中，将 parents[3] 设为 1。Approach 3在 Approach2 中观察到，当按照层次遍历的顺序给二叉树编号时，假如树具有complete的特性，parent 和 child 的编号是有规律可循的：编号为 k 的节点所对应的 parent 编号为(k-1)/2，即 parent(k) == (k-1)/2。进一步地，假如将 0th 的位置空出，则有以下规律： leftChild(k) $= k*2$ rightChild(k) $= k*2 + 1$ parent(k) = $k/2$ 因此，只需要一个 keys 数组存放键值即可，无需另一个数组存放树的结构。13.3 Implementation ConsiderationThe Implementation You may find the Princeton implementation of a heap useful. Here is a more detailed explanation of each of the methods. My implementation based on Sp18 lab10 is Here. A record of Sp18 lab10 will be released soon!" } ]
